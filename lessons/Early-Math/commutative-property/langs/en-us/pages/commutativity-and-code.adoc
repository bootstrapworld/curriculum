= Commutativity and Code (Images)

++++
<style>
  table {grid-template-rows: 3fr 1fr !important;}
  div.circleevalsexp .value,
  div.circleevalsexp .studentBlockAnswerFilled { min-width:unset; }
</style>
++++

Commutativity in code means that we can change the order of a function's arguments and still get exactly the same result. Complete the exploration to determine if @show{(code 'beside)}, @show{(code 'above)}, and @show{(code 'overlay)} are commutative.

@n *Is @show{(code 'beside)} commutative?* Make a prediction, then translate the two Circles of Evaluation into code. Test your code in @proglang.

[.FillVerticalSpace, cols="^.^1,^.^4,^.^4"]
|===
| Circle of Evaluation |@show{(coe '(beside aqua-star orange-dot))} | @show{(coe  '(beside orange-dot aqua-star))}
| Code | @ifsoln{@show{(code '(beside aqua-star orange-dot))}} | @ifsoln{@show{(code  '(beside orange-dot aqua-star))}}

|===

@n Did the two Circles of Evaluation produce _identical_ images? Explain. @fitb{}{@ifsoln{No. For the first Circle of Evaluation,}}

@fitb{}{@ifsoln{the aqua star was on the left, but for the second Circle, it was on the right.}}

@n *Is @show{(code 'above)} commutative?* Make a prediction, then draw a second Circle of Evaluation that changes the order of the arguments. Translate both Circles into code and test it out in @proglang.

[.FillVerticalSpace, cols="^.^1,^.^4,^.^4"]
|===
| Circle of Evaluation |@show{(coe '(above  blue-rec orange-dot))} | @ifsoln{@show{(coe  '(above orange-dot blue-rec))}}
| Code | @ifsoln{@show{(code '(above blue-rec orange-dot))}} | @ifsoln{@show{(code '(above orange-dot blue-rec))}}

|===

@n Did the two Circles of Evaluation produce _identical_ images? Explain. @fitb{}{@ifsoln{No. For the first Circle of Evaluation,}}

@fitb{}{@ifsoln{the blue rectangle was on the top, but for the second Circle, it was on the bottom.}}

@n *Is @show{(code 'overlay)} commutative?* @show{(code 'overlay)} takes in two images and produces an image. Draw two Circles of Evaluation that will help you decide if @show{(code 'overlay)} is commutative. Translate your Circles into code and test the code.

[.FillVerticalSpace, cols="^.^1,^.^4,^.^4"]
|===
| Circle of Evaluation ||
| Code | |

|===

@n Did the two Circles of Evaluation produce _identical_ images? Explain. @fitb{}{@ifsoln{No. For the first Circle of Evaluation,}}

@fitb{}{@ifsoln{the blue rectangle was on the left, but for the second Circle, it was on the right.}}



@n Were any of the above functions commutative? Explain. @fitb{}{}

@fitb{}{}

@fitb{}{}

