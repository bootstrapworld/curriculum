= The Additive Inverse Property

@description{Students develop a more nuanced interpretation of the Commutative and Associative Properties as a result of their exploration of the inverse relationship between addition and subtraction.}

@lesson-prereqs{associative-property}

@keywords{Associative Property, Commutative Property}

[@lesson-intro-table]
|===

| Lesson Goals
| Students will be able to...

* nothing

| Student-facing Lesson Goals
|

* nothing

| Materials
|[.materials-links]
@material-links

| Key Points For The Facilitator
|
* nothing
|===

== The Additive Inverse Property @duration{10 minutes}

=== Investigate

For the remainder of the activity, we will examine examples blocks. The first one includes only examples that pass. The second one has some errors! And the third one includes just one examples... *you* will be responsible for providing additional examples! @show{(code '(+ 9 2))}

@show{
(code '(define (red-shape shape)
  (cond
    [(string=? shape "circle")     (circle 20 "solid" "red")]
    [(string=? shape "triangle")   (triangle 20 "solid" "red")]
    [(string=? shape "rectangle")  (rectangle 20 20 "solid" "red")]
    [(string=? shape "star")       (star 20 "solid" "red")]
	[else (text "Unknown shape name!" 20 "red")])))
}

@slidebreak

@lesson-instruction{
- We know that all functions will need an open parentheses and at least one input!
- We don't know the Domain, so we don't know how many inputs or what types they are. But we can always guess, and if we get it wrong we'll use the error message as a clue.
- Type @show{(code '(sort animals-table))} in the Interactions Area and read the error message.
}

@QandA{
@Q{What _hint_ does the error message give us about how to use this function?}
@A{image{images/sort-error.png, 650}}
@A{The the sort function expects 3 arguments and its Domain is Table, String, Boolean. If we don't give it those three things we'll get an error instead of the sorted table we want.}
}

@slidebreak

- At each point in our linear model, @math{y} is the _predicted median lifespan_, and @math{x} is the _log of per-capita gdp_.

- We want @math{x} to represent the **original, un-transformed** value, simply using _per-capita gdp_ as-is...

- We've learned that:

** the *slope* in the transformed, linear model is the same as the *log coefficient* in the un-transformed logarithmic model

** the *vertical shift* in the transformed, linear model is the same as the *vertical shift* in the un-transformed logarithmic model


=== Synthesize

- Using @proglang allows us to evaluate arithmetic expressions easily and efficiently. In your own words, describe _how_ you tested the equivalence of different expression - and how you interpreted the results that @proglang produced.
- In @proglang, what does it mean for a test to pass? What does it mean for a test to fail?
- What did this programming exploration teach you about the additive inverse?
