= The Additive Inverse Property

@description{Students develop a more nuanced interpretation of the Commutative and Associative Properties as a result of their exploration of the inverse relationship between addition and subtraction.}

@lesson-prereqs{associative-property}

@keywords{Associative Property, Commutative Property}

[@lesson-intro-table]
|===

| Lesson Goals
| Students will be able to...

* nothing

| Student-facing Lesson Goals
|

* nothing

| Materials
|[.materials-links]
@material-links

| Key Points For The Facilitator
|
* nothing
|===

== The Additive Inverse Property @duration{10 minutes}

=== Investigate

@ifnotslide{
THis is @show{(coe '(* 12 34))}

}

For the remainder of the activity, we will examine examples blocks. The first one includes only examples that pass. The second one has some errors! And the third one includes just one examples... *you* will be responsible for providing additional examples! @show{(coe '(+ 9 2))}

@show{
(code '(define (red-shape shape)
  (cond
    [(string=? shape "circle")     (circle 20 "solid" "red")]
    [(string=? shape "triangle")   (triangle 20 "solid" "red")]
    [(string=? shape "rectangle")  (rectangle 20 20 "solid" "red")]
    [(string=? shape "star")       (star 20 "solid" "red")]
	[else (text "Unknown shape name!" 20 "red")])))
}

@slidebreak



@QandA{
@Q{What _hint_ does the error message give us about how to use this function?}
@A{image{images/sort-error.png, 650}}
@A{The the sort function expects 3 arguments and its Domain is Table, String, Boolean. If we don't give it those three things we'll get an error instead of the sorted table we want.}
}

@slidebreak

[cols="3,^1,^1,^1", options="header"]
|===
| Title
| Time
| Team Size
| Budget

| Call of Duty: Modern Warfare 2
| 2 years
| 500+
| 50m+

| Final Fantasy VII
| 3 years
| 100+
| 40-45m

| Shadow of the Tomb Raider
| 3+ years
| 100+
| 75m+

|===

@slidebreak

- At each point in our linear model, @math{y} is the _predicted median lifespan_, and @math{x} is the _log of per-capita gdp_.

- We want @math{x} to represent the **original, un-transformed** value, simply using _per-capita gdp_ as-is...

- We've learned that:

** the *slope* in the transformed, linear model is the same as the *log coefficient* in the un-transformed logarithmic model

** the *vertical shift* in the transformed, linear model is the same as the *vertical shift* in the un-transformed logarithmic model

@ifproglang{pyret}{

@slidebreak

pyret aaaa

@slidebreak

pyret bbbb


}


=== Synthesize

- Using @proglang allows us to evaluate arithmetic expressions easily and efficiently. In your own words, describe _how_ you tested the equivalence of different expression - and how you interpreted the results that @proglang produced.
- In @proglang, what does it mean for a test to pass? What does it mean for a test to fail?
- What did this programming exploration teach you about the additive inverse?
