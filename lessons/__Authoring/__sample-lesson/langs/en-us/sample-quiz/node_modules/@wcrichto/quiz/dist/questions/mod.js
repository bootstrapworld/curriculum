import classNames from "classnames";
import _ from "lodash";
import React, { useContext, useId, useMemo, useRef, useState } from "react";
import { useForm } from "react-hook-form";
import { MarkdownView } from "../components/markdown";
import { MoreInfo } from "../components/more-info";
import { QuizConfigContext, useCaptureMdbookShortcuts } from "../lib";
import { MultipleChoiceMethods } from "./multiple-choice";
import { ShortAnswerMethods } from "./short-answer";
import { TracingMethods } from "./tracing";
export { MultipleChoiceMethods } from "./multiple-choice";
export { ShortAnswerMethods } from "./short-answer";
export { TracingMethods } from "./tracing";
let methodMapping = {
    ShortAnswer: ShortAnswerMethods,
    Tracing: TracingMethods,
    MultipleChoice: MultipleChoiceMethods
};
export let getQuestionMethods = (type) => methodMapping[type];
let questionNameToCssClass = (name) => {
    let output = [];
    for (let i = 0; i < name.length; ++i) {
        if (i > 0 && name[i].match(/[A-Z]/)) {
            output.push("-");
        }
        output.push(name[i].toLowerCase());
    }
    return output.join("");
};
let BugReporter = ({ quizName, question }) => {
    let [show, setShow] = useState(false);
    // Disable mdbook shortcuts if the bug reporter is opened and we're not
    // fullscreen
    useCaptureMdbookShortcuts(show);
    let onSubmit = event => {
        let data = new FormData(event.target);
        let feedback = data.get("feedback").toString();
        window.telemetry.log("bug", {
            quizName,
            question,
            feedback
        });
        event.preventDefault();
        setShow(false);
    };
    return (React.createElement("div", { className: "bug-report" },
        React.createElement("button", { type: "button", title: "Report a bug in this question", onClick: () => setShow(!show) }, "\uD83D\uDC1E"),
        show && (React.createElement("div", { className: "reporter" },
            React.createElement("button", { type: "button", className: "close", onClick: () => setShow(false) }, "\u2715"),
            React.createElement("h3", null, "Report a bug"),
            React.createElement("p", null, "If you found an issue in this question (e.g. a typo or an incorrect answer), please describe the issue and report it:"),
            React.createElement("form", { onSubmit: onSubmit },
                React.createElement("textarea", { name: "feedback", "aria-label": "Bug feedback" }),
                React.createElement("input", { type: "submit", "aria-label": "Submit bug feedback" }))))));
};
let now = () => new Date().getTime();
const EXPLANATION_HELP = `
Normally, we only observe *whether* readers get a question correct or incorrect. 
This explanation helps us understand *why* a reader answers a particular way, so 
we can better improve the surrounding text.
`.trim();
let MultipartContext = ({ title, multipart, question }) => (React.createElement("div", { className: "multipart-context" },
    React.createElement("p", null,
        React.createElement("strong", null,
            "Question ",
            title.substring(0, 1),
            " has multiple parts."),
        " The box below contains the shared context for each part."),
    React.createElement("div", { className: "multipart-context-content" },
        React.createElement(MarkdownView, { markdown: multipart[question.multipart] }))));
export let QuestionView = ({ multipart, question, index, title, attempt, questionState, onSubmit }) => {
    let { name: quizName, showBugReporter } = useContext(QuizConfigContext);
    let start = useMemo(now, [quizName, question, index]);
    let ref = useRef(null);
    let [showExplanation, setShowExplanation] = useState(false);
    let methods = getQuestionMethods(question.type);
    if (!methods) {
        return (React.createElement("div", null,
            "QUIZ FORMAT ERROR: unknown question type ",
            React.createElement("code", null, question.type)));
    }
    let formValidators = useForm();
    let required = (name, options) => {
        let attrs = formValidators.register(name, { ...options, required: true });
        let className = classNames({
            error: formValidators.formState.errors[name]
        });
        return { ...attrs, className };
    };
    let questionClass = questionNameToCssClass(question.type);
    let submit = formValidators.handleSubmit(data => {
        let answer = methods.getAnswerFromDOM
            ? methods.getAnswerFromDOM(data, ref.current)
            : data;
        let comparator = methods.compareAnswers || _.isEqual;
        let correct = comparator(question.answer, answer);
        onSubmit({
            answer,
            correct,
            start,
            end: now(),
            explanation: data.explanation
        });
    });
    let shouldPrompt = question.promptExplanation && attempt === 0;
    let explanationId = useId();
    return (React.createElement("div", { className: classNames("question", questionClass) },
        React.createElement("div", { className: "prompt" },
            React.createElement("h4", null,
                "Question ",
                title),
            question.multipart && (React.createElement(MultipartContext, { question: question, multipart: multipart, title: title })),
            React.createElement(methods.PromptView, { prompt: question.prompt }),
            window.telemetry && showBugReporter && (React.createElement(BugReporter, { quizName: quizName, question: index }))),
        React.createElement("form", { className: "response", ref: ref, onSubmit: submit },
            React.createElement("h4", null, "Response"),
            React.createElement("fieldset", { disabled: showExplanation },
                React.createElement(methods.ResponseView, { key: `${quizName}-question${index}`, prompt: question.prompt, answer: question.answer, submit: submit, state: questionState, formValidators: { ...formValidators, required } })),
            showExplanation && (React.createElement(React.Fragment, null,
                React.createElement("p", null,
                    React.createElement("br", null),
                    React.createElement("label", { htmlFor: explanationId },
                        "In 1-2 sentences, please explain why you picked this answer. \u00A0\u00A0",
                        React.createElement(MoreInfo, { markdown: EXPLANATION_HELP }))),
                React.createElement("textarea", { id: explanationId, title: "Explanation", ...required("explanation") }))),
            shouldPrompt && !showExplanation ? (React.createElement("button", { type: "button", onClick: () => setShowExplanation(true) }, "Submit")) : (React.createElement("input", { type: "submit" })))));
};
export let AnswerView = ({ multipart, question, index, title, userAnswer, correct, showCorrect }) => {
    let { name: quizName, showBugReporter } = useContext(QuizConfigContext);
    let methods = getQuestionMethods(question.type);
    let questionClass = questionNameToCssClass(question.type);
    let multipartView = null;
    if (question.multipart) {
        let anchorId = `${quizName}-${question.multipart}`;
        if (title.substring(1, 2) === "a")
            multipartView = (React.createElement("div", null,
                React.createElement("a", { id: anchorId }),
                React.createElement(MultipartContext, { question: question, multipart: multipart, title: title })));
        else
            multipartView = (React.createElement("div", { className: "multipart-context" },
                React.createElement("a", { href: `#${anchorId}` },
                    "Return to question context ",
                    React.createElement("span", { className: "rotate-arrow" }, "\u21B3"))));
    }
    return (React.createElement("div", { className: classNames("answer", questionClass) },
        React.createElement("div", { className: "prompt" },
            React.createElement("h4", null,
                "Question ",
                title),
            multipartView,
            React.createElement(methods.PromptView, { prompt: question.prompt }),
            window.telemetry && showBugReporter && (React.createElement(BugReporter, { quizName: quizName, question: index }))),
        React.createElement("div", { className: "answer-row" },
            React.createElement("div", null,
                React.createElement("div", { className: "answer-header" }, "You answered:"),
                React.createElement("div", null,
                    React.createElement(methods.AnswerView, { answer: userAnswer, baseline: question.answer, prompt: question.prompt }))),
            showCorrect && !correct && (React.createElement("div", null,
                React.createElement("div", { className: "answer-header" }, "The correct answer is:"),
                React.createElement("div", null,
                    React.createElement(methods.AnswerView, { answer: question.answer, baseline: question.answer, prompt: question.prompt }))))),
        showCorrect && question.context && (React.createElement("div", { className: "context" },
            React.createElement(MarkdownView, { markdown: `**Context**:\n${question.context}` })))));
};
//# sourceMappingURL=mod.js.map