= Row and Column Lookups

@description{Students review how to extract individual Rows from a table, then learn how to answer lookup questions by extracting a single value from a Row.}

@lesson-prereqs{contracts-visualizations, functions-examples-definitions}

@keywords{}

[@lesson-intro-table]
|===

| Lesson Goals
| Students will be able to...

@objectives
@objective{Extract any Row from a table in Pyret.}
@objective{Extract the value of any column in a given Row in Pyret.}

| Student-facing Lesson Goals
|

- Let's practice making data visualizations to answer our questions about the data and retrieving information from tables.

| Materials
|[.materials-links]
@material-links

|===

== Row Lookups

=== Overview
Students review value definitions in Pyret, and practice extracting individual rows for later use.

=== Launch

Sometimes it's helpful to define a row that has a property that we care about so that we can test whether or not our code is handling a subset of the population correctly.

There are already a few rows defined in the @starter-file{animals}. Let's have a look!

@teacher{
We'd suggest projecting the starter file for this part of the lesson to keep everyone together, but if it works better for you, you could also have them open their own at this point.
}

@QandA{
@Q{What are the names of the sample rows you see defined?}
@A{cat-row}
@A{dog-row}

@Q{What function is used to extract a row from the table?}
@A{`row-n`}

@Q{What row would `row-n(animals-table, 1)` return?}
@A{The second row.}
}

Notice that we could have defined the first row from the animals table using:

`sasha = row-n(animals-table, 0)`

But, it's often more useful to name our Row definitions according to the _property we care about_. In this case, the fact that this row is a cat is _much_ more interesting than the fact that her name is Sasha, so the starter file uses:

`cat-row = row-n(animals-table, 0)`


@lesson-instruction{
- There are many other subsets that we might want to analyze besides dogs and cats. Trends for old animals might be worth investigating separately, for example.
- With your partner, turn to the @dist-link{courses/data-science/back-matter/pages/animals-dataset.adoc, Animals Table} and see how many different useful subsets you can brainstorm!
}

=== Investigate

@lesson-instruction{
- If we were analyizing a subset of lizards, it would make sense to add a definition for `lizard-row` to the Animals Dataset.
- With your partner, find the index of the first lizard that appears on the @dist-link{courses/data-science/back-matter/pages/animals-dataset.adoc, Animals Table} and use it to define `lizard-row` beneath `cat-row` in your @starter-file{animals}.
- Then click "Run" and type `lizard-row` into the Interactions Area to see what it returns.
- Complete @printable-exercise{defining-rows.adoc}.
- Add the rows you just defined to your starter file. _We will be using them!_
}

@teacher{If you do a lot of differentiating in your classroom, you might want to make a starter file that has these rows predefined for some of your students.}

=== Synthesize
- What other properties of the Animals Data set might be interesting to analyze, besides the list from @printable-exercise{defining-rows.adoc}?
- What are some properties of *your dataset* that you might want to define rows for?

== Column Lookups

=== Overview
Students learn how to access a particular column from a row.

=== Launch
We can access _specific columns_ of a Row, by using a *Row Accessor*.

- start with a row value:
  ** a `row-n` expression just like the ones we've been working with
  ** the name of a row that we have already defined
- end with square brackets `[ ]` containing the name of the column where the value can be found.

Here are three examples that use row accessors to get at different columns from the first row in the animals-table.

@indented{
[cols="1a,1a", options="header"]
|===
| Without Predefined Rows
| Using Predefined Rows

|

```
row-n(animals-table, 0)["name"]
row-n(animals-table, 0)["age"]
row-n(animals-table, 0)["fixed"]
```

|

```
cat-row["name"]
cat-row["age"]
cat-row["fixed"]
```

|===
}

=== Investigate

Sometimes we want to ask questions about a specific Row, or do some computations with that Row:

- Is the age of our `lizard-row` animal more than 3?
- How many _kilograms_ does our `rabbit-row` weigh?
- Is the species of our `fixed-row` animal a `"dog"`?
- Could we use the `age` of our `male-row` as the size of a solid, green triangle?

We can use our knowledge of lookups, operators and functions to do just that!

@lesson-instruction{
- Turn to @printable-exercise{lookup-questions-matching.adoc}.
- Notice the `pet-table` at the top of the page. All of the questions on this page will refer back to that table.
- Complete the page, discussing your thinking with a partner.
}

@teacher{Confirm that students have correctly complete the page before moving on. If they need more matching practice before moving on have them complete @opt-printable-exercise{more-practice-w-lookups.adoc}.}

Now that we know how to lookup a value for a specific column of a row, let's practice some of the things we might be able to do with that information!

@teacher{Students will need to have all of the values from @printable-exercise{defining-rows} defined in the Definitions Area in order to work through this next set of exercises.}

@lesson-instruction{
- Open your copy of the @starter-file{animals} and make sure the Definitions Area includes defintions for all of the rows from @printable-exercise{defining-rows}.
- Turn to @printable-exercise{lookup-expressions.adoc} and notice that the code at the top uses the "age" of `old-row` to determine the size of the triangle.
- Type the code into the Interactions Area and test it out.
- With a partner, work through @printable-exercise{lookup-expressions.adoc}
}

@teacher{
Have students share their most creative uses of lookups. Did anyone use three or more columns from a Row? Did anyone use more than one Row in the same expression?
}

=== Synthesize
Once we know how to perform computations with a _single_ Row, we can use our knowledge of functions to generalize that computation to work with _every_ Row in a Table. This allows us to write some pretty powerful table functions that...

- Filter a table to show only animals older than 3
- Filter a table to show only animals whose species is `"dog"`
- Build a column that shows all the animals' weights in kilograms
- Build a column that represents the age of each animal as a solid, green triangle

@slidebreak

@QandA{
@Q{Why would defining individual Rows be important, if our goal is to write table functions?}
@A{Writing examples requires sample values, and table functions need sample Rows}
}

@pd-slide{
Tables have tons of data - of all different types! - arranged into Rows and Columns. They feel like a monolith.

With lookups, we've given kids surgical precision to hone in on _an individual row_, and to hone in on an _individual value_ from that row. That might be kind of important if we want to do something like... *filter a table* showing only the individual rows where species equals dog.

Now we can use definitions to make our lives easier! If we find that we're writing the same thing over and over and over, we could just define `cat-row` instead of needing to retype all the lookup code every time.
}


