= Composing Transformers

@description{Students learn how to compose Transformers, which act as functions operating on tables.}

@lesson-prereqs{codap-building}

@keywords{}

[@lesson-intro-table]
|===
| Lesson Goals
| Students will be able to...

* Compose Transformers to create more sophisticated analyses
* Diagram their composition to make sense of the order of operations
* Find bugs when Transformers are not composed in the correct order

| Student-facing Lesson Goals
|

* Let's practice combining Transformers

| Materials
|[.materials-links]

@material-links

| Preparation
|
* This lesson requires each pair of students to create a cut-out set of "Transformer Cards". Have scissors available.
|===

== Creating Transformers (Review) @duration{25 minutes}

=== Overview

Students practice creating, naming, and saving all of the Trasnsformer types that they have discovered: Filter, Build Attribute, and Transform Attribute.

=== Launch

One of the perks of using a tool like CODAP is that it invites experimentation, prompting us to play with a variety of inputs until we have designed exactly the Transformer we need.

Sometimes, however, relying on experimentation can limit our ability to _plan_ our data transformations. Familiarizing ourselves with exactly which inputs each Transformer requires can help us to efficiently transform data, without relying on guessing and checking every time.

Each Transformer we've worked with consumes a different amount of arguments, represented in the table below.

[cols= "10,10,10",options="header"]
|===
| Filter
| Build Attribute
| Transform Attribute

| Transformer Type

Dataset

Expression

| Transformer Type

Dataset

Name of New Attribute

Expression

| Transformer Type

Dataset

Attribute to Transform

New Name for Transformed Attribute

Expression

|===


[.lesson-instruction]
- How many arguments does Filter require? How about Build Attribute? Transform Attribute?
** _Filter requires 2 arguments. Build Attribute requires 3 arguments. Transform Attribute requires 4 arguments._
- Why does each Transformer require a different number of arguments?
** _All Transformeres require a Transformer type and a dataset. Beyond that, Filter only needs a Boolean to know which rows to include and exclude from the new dataset. Build and Transform both require a new attribute name. Transform also needs to know which attribute is being transformed._


=== Investigate

In the subsequent activities, "Transformer Cards" are a tool for students to think about what specific arguments each Transformer requires. These cards will later support students in composing Transformers.

Let's practice creating Transformer Cards to represent various Transformers.

[.lesson-instruction]
- As a class, complete  @printable-exercise{create-transformer-cards.adoc}.
- In the last column, give each Transformer a useful and descriptive name.
- On your own, complete the handout @handout{create-transformer-cards-2.adoc}.

Confirm that students have correct responses on their Transformer Cards, as these cards are central to the subsequent segment of the lesson.


=== Synthesize

- Did you get more comfortable creating Transformer cards as you completed these two pages?
- What obstacles did you encounter?
- What is the value of naming Transformers?


== Composing Transformers @duration{25 minutes}

=== Overview

Students learn to diagram composed Transformers using the Circles of Evaluation. This tool has deep roots in both @lesson-link{order-of-operations} and @lesson-link{function-composition}, and math teachers may want to take a detour through one or both of these lessons to support those learning goals.


=== Launch

We already know how to filter, transform, and build columns - but what if we want to do _multiple things, all at once?_ Filtering, transforming and building are powerful transformations, but when they are _combined_ they become even more powerful!

Let's play a game to explore what happens when we combine Transformers.

[.lesson-instruction]
--
*Get Ready:*

- Each pair of students needs one set of cut-out cards from @handout{create-transformer-cards-2.adoc}.
- Each pair of students will need to refer to the three-row table of animals on the top of the page.

*Gameplay:*

- Student 1: Randomly choose two cards and lay them down face up in front of your partner _in the order that you chose them_.
- Student 2: Determine the output of "playing" those two cards _in that order_ by referring to the three-row table of animals.
- Return the cards to the deck and play another round.

*Challenges:*

- See if you can deal your partner two cards that...
** produce an error
** produce the same dataset, regardless of the order in which they are dealt
** produce a dataset with just _one_ animal
** produce an empty dataset (not an error!)
- What did you discover about _composing_ Transformers?
--

If we use our Transformers in the wrong order (trying to filter by a column that doesnâ€™t exist yet, for example), we might wind up crashing the program. *Order matters: Build / Transform, _then_ Filter.*

=== Investigate

One way to organize our thoughts is to diagram what we want to do, using the @vocab{Circles of Evaluation}. The rules are simple:

**1) Every Circle must have one - and only one! - saved Transformer written at the top.**

Each Transformer card that you created required different information, including the Transformer Type, the dataset, the expression, etc.

Once a Transformer is named and _saved_, however, it needs just *one* piece of information from you: the dataset that you want to transform! This leads us to the second rule of Circles of Evaluation:

**2) The dataset that the Transformer consumes is written in the the middle of the Circle.**

Let's think about our Transformer cards again. The @vocab{Circle of Evaluation} for `filter-if-fixed` looks like this:

@show{(coe '(filter-if-fixed t)) }

But what if we want to play _another_ Transformer card? The  Circle of Evaluation above produces a _table_ ... which brings us to the third rule of Circles of Evaluation:

**3) Circles can contain other Circles!**

Let's say that after drawing `filter-if-fixed`, your partner draws `filter-if-young`. You could represent this sequence of cards like this:

@show{(coe '(filter-if-young (filter-if-fixed t))) }

A perk of composing saved Transformers is that everything is just a "view" of the original data, rather than a _change_ made to that data. Changes can cause tables to go out of sync, resulting in hard-to-find bugs and invalid results. With Transformers, any updates made to the original dataset will flow through the composition, keeping everything in sync. Transformers can also be reused, eliminating duplicate work.

[.strategy-box, cols="1", grid="none", stripes="none"]
|===
|
@span{.title}{Tip: Renaming Tables}

Encourage students to rename tables descriptively.

As students compose Transformers, they may note that table names start to become quite lengthy, i.e. `(weight-in-kg(filter-if-light(Animals-Dataset)))`. That's a lot of parentheses! As an alternative, students might consider renaming the table something simpler. For instance, `light-animals-in-kg` would be a more easily interpreted table name.
|===


Sometimes, the hardest part of solving a problem is knowing what you want to do, rather than worrying about how to do it. For example, sometimes solving an equation is a lot easier than __setting it up in the first place__. Circles of Evaluation give us an opportunity to think through what we want to do, before getting in front of the computer and worrying about how to do it. Circles of Evaluation let us think and plan, without getting bogged down by small details.

[.lesson-instruction]
- Complete @printable-exercise{pages/matching-composed-transformers.adoc}.
- When you're finished, do @printable-exercise{pages/planning-transformer-composition.adoc}, where you will draw composed Circles of Evaluation based on a given prompt.


=== Synthesize

Was it helpful to think about the Circles, without worrying about CODAP? Why or why not?


