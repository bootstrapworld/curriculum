= Composing Transformers


@description{Students learn how to compose Transformers, which act as functions operating on tables.}

@lesson-prereqs{codap-building}

@keywords{}

[@lesson-intro-table]
|===
| Lesson Goals
| Students will be able to...

* Compose Transformers to create more sophisticated analyses.
* Diagram their composition to make sense of the order of operations
* Find bugs when Transformers are not composed in the correct order

| Student-facing Lesson Goals
|

* Let's practice combining Transformers

| Materials
|[.materials-links]

@material-links

| Preparation
|
* All students should log into @starter-file{program-list} and open their saved "Animals Starter File". If they don't have the file, they can open a new one from @starter-file{animals}.
|===

== Design Recipe Practice @duration{25 minutes}

=== Overview
In this lesson students build on what they have already learned to formalize their understanding of the Design Recipe, and then gain fluency with using the Design Recipe.

=== Launch
When filtering rows or building columns, we need to write Transformer expressions. __This should be done carefully!__ We want our results to be rock solid and accurate, especially if they're going to be used in ways that affect the world around us.

The Design Recipe is a sequence of steps that helps us document, test out, and write Transformer expressions that let us dig deeper into our data, and analyze it more carefully. It's important for this to be like second nature, so let's get some practice using it.

[.lesson-instruction]
Let's look at @printable-exercise{pages/design-recipe-1.adoc} together.

First, we need to decide which Transformer to use: Filter, Transform, or Build. Based on the Transformer's already-provided name, students should deduce that they will use Filter. They can then record the Transformer's name on the line.

@image{images/transformer-name.png, 800, "top section of a Design Recipe"}

Next, we provide *example tables*. In this case, we want to know the animals' names and their species, so we write down those column names. We want to list a few different animals - at least one that is a dog, and at least one that is not - to represent the variety of animals on the table. Then we think about what our transformed table will look like:

- Will Sasha be on the new table? _No, Sasha is a cat. We only want dogs!_

- Will Fritz be on the new table? _Yes, Fritz is a dog._

- Will Toggle be on the new table? _Yes, Toggle is a dog._

@image{images/example-tables.png, 800, "filled in example tables from Design Recipe worksheet" }

Now, we are ready to drill down on the contents of our Transformer.

- First - the *contract*, which requires a domain (what type of data will we provide) and a range (what type of data will be produced). Whenever we are filtering, we can expect the contract to be the same: Row -> Boolean.

- Next, we need a clear *purpose statement*, which describes what the expression does to each row. In this case, the expression will consume an animal and compute whether the species is "dog" - as our example tables (above) demonstrate!

- And finally, we enter our *expression*, in this case: `species = "dog"`.

@image{images/contents.png, "contract, purpose statement, expression", 800}

Each time students encounter a new word problem, we encourage working through it with paper and pencil, as above; the Design Recipe slows down students' thinking and encourages them to reason through each scenario fully rather than guessing haphazardly.


=== Investigate

[.lesson-instruction]
- Open your saved @starter-file{animals}.
- Define the Transformers and expressions on @printable-exercise{pages/design-recipe-1.adoc} and @printable-exercise{pages/design-recipe-2.adoc}.


[.strategy-box, cols="1", grid="none", stripes="none"]
|===
|
@span{.title}{Optional: Combining Booleans}

Suppose we want to build a table of Animals that are fixed _and_ old, or a table of animals that are cats _or_ dogs?

By using the `and` and `or` operators, we can _combine_ Boolean tests on a single Transformer, like `Filter`. Once we've opened the `Filter` Transformer, we would tell CODAP to keep all rows that satisfy `Species = "cat" and Species = "dog"`. This is handy for more complex programs! For example, we might want to ask if a character in a video game has run out of health points _and_ if they have any more lives. We might want to know if someone’s ZIP Code puts them in Texas or New Mexico. When you go out to eat at a restaurant, you might ask what items on the menu have meat and cheese.

When we want to compose _different_ Transformers, however, this strategy will not work. We'll need to find another way!
|===

=== Synthesize
- Did you find yourselves getting faster at using the Design Recipe?
- What patterns or shortcuts are you noticing, when you use the Design Recipe?



== Circles of Evaluation @duration{25 minutes}

=== Overview
Students learn to diagram Transformers using @vocab{Circles of Evaluation}. This tool has deep roots in both @lesson-link{order-of-operations} and @lesson-link{function-composition}, and math teachers may want to take a detour through one or both of these lessons to support those learning goals.

=== Launch

A @vocab{Circle of Evaluation} is a way to organize our thoughts and diagram what we want a given Transformer to do. Circles of Evaluation require a bit _more_ planning and a bit _less_ experimentation than creating a Transformer in CODAP. The rules are simple:

**1) Every Circle must have one - and only one! - Transformer type written at the top.**

**2) The arguments of the Transformer are written left-to-right, in the middle of the Circle.** Note that different Transformers require different arguments!

[.lesson-instruction]
--
- What do you Notice about the @vocab{Circles of Evaluation} below? What do you Wonder?

[cols= "^.^5, ^.^7" ,options="header"]
|===
| Filter
| Build Attribute


| @show{(coe '(TransformerType Dataset Expression))}
| @show{(coe '(TransformerType Dataset "Name of New Attribute" Expression))}
|===

[cols= "^.^10",options="header"]
|===
| Transform Attribute
| @show{(coe '(TransformerType Dataset "Attribute to Transform" "New Name for Transformed Attribute" Expression))}
|===

- How many arguments does Filter require? How about Build Attribute? Transform Attribute?
** _Filter requires 2 arguments. Build Attribute requires 3 arguments. Transform Attribute requires 4 arguments._
- Why is naming your Transformers important?
--

=== Investigate

Let's practice creating Circles of Evaluation to represent various Transformers.

[.lesson-instruction]
- Turn to @printable-exercise{transformers-and-coes.adoc}.
- Complete the table at the top of the page to use as a reference.
- Respond to the prompts, drawing Circles of Evaluation that represent the transformation needed to create the desired table.
- In the last column, give each Transformer a useful and descriptive name.

=== Synthesize

- Was it helpful to think about the Circles without worrying about CODAP? Why or why not?
- What is the value of naming Transformers?



== Composing Transformers @duration{25 minutes}

=== Overview

Filtering, transforming and building are powerful transformations, but when they are _combined_ they become even more powerful!

=== Launch

We already know how to filter, transform, and build columns - but what if we want to do _multiple things, all at once?_

A journalist comes to the shelter who wants to write a story about a successful pet adoption -- but she has a very specific set of criteria. The reporter wants to report on the adoption of an animal that weighs *no more than 9 kilograms* (they don't use "pounds" in Britain!).

[.lesson-instruction]
- To provide the journalist with a list of possible pets, what transformations do we need to do to apply to the @starter-file{animals}?
** __We need to filter, showing only rows that are greater than 9kg. We also need to add a column that shows weight in kilograms, dividing pounds by 2.205.__
- What do you think will happen if we try to filter animals that weigh more than 9kg, before actually building a `"kilos"` column?
** __(Sample responses:) It will crash! The computer won't like it!__

If we use our Transformers in the wrong order (trying to filter by a column that doesn’t exist yet), we might wind up crashing the program. But even worse, the program might run but produce nonsensical results!

[.lesson-point]
Order matters: Build / Transform, _then_ Filter.

=== Investigate

Let diagram what we need to do for the journalist using the Circles of Evaluation.

Note: @printable-exercise{composing-transformers.adoc} is designed to be completed as a class, with discussion woven throughout.

[.lesson-instruction]
- We always build first, so let's start there.
- For Q1 on @printable-exercise{composing-transformers.adoc}, diagram how you would build a column that gives each animal's weight in kilograms.
- What will this Circle of Evaluation produce?
** _It will produce a table with a new column that gives the animals' weights in kilograms._

The Transformer produces a _table_! We will use this table as our dataset for the Filter transformer we are about to create... which brings us to the third rule of Circles of Evaluation:

**3) Circles can contain other Circles!**

[.lesson-instruction]
- In the _inner_ Circle of Q3, copy down the Circle of Evaluation that you drew for Q1. We'll use the inner Circle as the Outer Circle's first argument.
- Draw a Circle-within-a-Circle to create a table that includes only animals that weigh more than 9 kilograms.




=== Investigate

[.lesson-instruction]
- Complete @printable-exercise{pages/composing-table-operations.adoc}.
- Optional: For more of a challenge, tackle @opt-printable-exercise{pages/composing-table-operations-order-matters.adoc}



A perk of composing Transformers is that everything is just a "view" of the original data, rather than a _change_ made to that data. Changes can cause tables to go out of sync, resulting in hard-to-find bugs and invalid results. With Transformers, any updates made to the original dataset will flow through the composition, keeping everything in sync. Transformers can also be reused, eliminating duplicate work.

[.strategy-box, cols="1", grid="none", stripes="none"]
|===
|
@span{.title}{Tip: Saving Transformers and Renaming Tables}

We also encourage students to rename tables descriptively. By the end of this exercise, the table students create will have quite a lengthy name: `(weight-in-kg(filter-if-light(Animals-Dataset)))`. That's a lot of parentheses! As an alternative, students might consider using renaming the table. For instance, `light-animals-in-kg` might be a more useful table name, here.
|===



[.lesson-point]
Circles of Evaluation let us think and plan, without worrying about small details.

Sometimes, the hardest part of solving a problem is knowing what you want to do, rather than worrying about how to do it. For example, sometimes solving an equation is a lot easier than __setting it up in the first place__. Circles of Evaluation give us an opportiunity to think through what we want to do, before getting in front of the computer and worrying about how to do it.

Armed with these tools, we can do some pretty complex analysis! We can even think of data displays as another kind of table operation. What will this Circle of Evaluation produce?

@show{(coe '(box-plot (filter (filter animals-table is-dog) is-young) "age"))}


=== Synthesize

Was it helpful to think about the Circles, without worrying about CODAP? Why or why not?

== Additional Exercises

@opt-printable-exercise{pages/building-from-circles-2.adoc}


We also encourage students to rename tables descriptively. By the end of this exercise, the table students create will have quite a lengthy name: `(weight-in-kg(filter-if-light(Animals-Dataset)))`. That's a lot of parentheses! As an alternative, students might consider using renaming the table. For instance, `light-animals-in-kg` might be a more useful table name, here.
