= The Design Recipe

@description{Students learn how to compose Transformers, which act as functions operating on tables.}

@lesson-prereqs{codap-building}

@keywords{}

[@lesson-intro-table]
|===
| Lesson Goals
| Students will be able to...

* Compose Transformers to create more sophisticated analyses.
* Diagram their composition to make sense of the order of operations
* Find bugs when Transformers are not composed in the correct order

| Student-facing Lesson Goals
|

* Let's practice combining Transformers

| Materials
|[.materials-links]

@material-links

| Preparation
|
* All students should log into @starter-file{program-list} and open their saved "Animals Starter File". If they don't have the file, they can open a new one from @starter-file{animals}.
|===

== Design Recipe Practice @duration{25 minutes}

=== Overview
In this lesson students build on what they have already learned to formalize their understanding of the Design Recipe, and then gain fluency with using the Design Recipe.

=== Launch

@printable-exercise{writing-purpose-statements.adoc}

When filtering rows or building columns, we need to write Transformer expressions. __This should be done carefully!__ We want our results to be rock solid and accurate, especially if they're going to be used in ways that affect the world around us.

The Design Recipe is a sequence of steps that helps us document, test out, and write Transformer expressions that let us dig deeper into our data, and analyze it more carefully. It's important for this to be like second nature, so let's get some practice using it.

[.lesson-instruction]
Let's look at @printable-exercise{pages/design-recipe-1.adoc} together.

First, we need to decide which Transformer to use: Filter, Transform, or Build. Based on the Transformer's already-provided name, students should deduce that they will use Filter. They can then record the Transformer's name on the line.

@image{images/transformer-name.png, 800, "top section of a Design Recipe"}

Next, we provide *example tables*. In this case, we want to know the animals' names and their species, so we write down those column names. We want to list a few different animals - at least one that is a dog, and at least one that is not - to represent the variety of animals on the table. Then we think about what our transformed table will look like:

- Will Sasha be on the new table? _No, Sasha is a cat. We only want dogs!_

- Will Fritz be on the new table? _Yes, Fritz is a dog._

- Will Toggle be on the new table? _Yes, Toggle is a dog._

@image{images/example-tables.png, 800, "filled in example tables from Design Recipe worksheet" }

Now, we are ready to drill down on the contents of our Transformer.

- First - the *contract*, which requires a domain (what type of data will we provide) and a range (what type of data will be produced). Whenever we are filtering, we can expect the contract to be the same: Row -> Boolean.

- Next, we need a clear *purpose statement*, which describes what the expression does to each row. In this case, the expression will consume an animal and compute whether the species is "dog" - as our example tables (above) demonstrate!

- And finally, we enter our *expression*, in this case: `species = "dog"`.

@image{images/contents.png, "contract, purpose statement, expression", 800}

Each time students encounter a new word problem, we encourage working through it with paper and pencil, as above; the Design Recipe slows down students' thinking and encourages them to reason through each scenario fully rather than guessing haphazardly.


=== Investigate

[.lesson-instruction]
- Open your saved @starter-file{animals}.
- Define the Transformers and expressions on @printable-exercise{pages/design-recipe-1.adoc} and @printable-exercise{pages/design-recipe-2.adoc}.


[.strategy-box, cols="1", grid="none", stripes="none"]
|===
|
@span{.title}{Optional: Combining Booleans}

Suppose we want to build a table of Animals that are fixed _and_ old, or a table of animals that are cats _or_ dogs?

By using the `and` and `or` operators, we can _combine_ Boolean tests on a single Transformer, like `Filter`. Once we've opened the `Filter` Transformer, we would tell CODAP to keep all rows that satisfy `Species = "cat" and Species = "dog"`. This is handy for more complex programs! For example, we might want to ask if a character in a video game has run out of health points _and_ if they have any more lives. We might want to know if someoneâ€™s ZIP Code puts them in Texas or New Mexico. When you go out to eat at a restaurant, you might ask what items on the menu have meat and cheese.

When we want to compose _different_ Transformers, however, this strategy will not work. We'll need to find another way!
|===

=== Synthesize
- Did you find yourselves getting faster at using the Design Recipe?
- What patterns or shortcuts are you noticing, when you use the Design Recipe?

