= Data-Driven Algorithms

@description{By exploring a spell checker program, students discover that AI relies on _data-driven algorithms_. When we provide more data to the computer, data-driven algorithms generally produce a higher quality output. }

@ifproglang{pyret}{
@lesson-prereqs{ds-intro}
}

@keywords{}

[@lesson-intro-table]
|===
| Lesson Goals
| Students will be able to...


| Student-facing Lesson Goals
|

- Let's play with spell checkers to learn about @vocab{data-driven algorithms}

| Materials
|[.materials-links]
@material-links

|===

== What do you know about AI? @duration{15 minutes}

=== Overview

Students think broadly about artificial intelligence before considering one specific example of AI: the spell checker.

=== Launch

The AI that we interact with—in fact the only type of AI that we have achieved—focuses on a single narrow task and has a limited range of abilities. Virtual assistants (Google Assistant, Siri, and Alexa, to name a few) are one example. These apps respond to voice commands in order to perform simple tasks (setting alarms, making phone calls, and answering questions). Can you think of any others?

@QandA{
@Q{What forms of AI appear in your life on a day-to-day basis?}
@A{Possible responses: TikTok’s algorithm, GPS, text prediction, chess playing computers, grammar correcting apps.}
@Q{What is the most impressive AI you have encountered in your daily life?}
@A{Allow students to share. }
}

@strategy{Are Search Engines AI?}{

Although some search engines (especially as of 2024) incorporate AI-generated summaries of content, we generally do *not* think of the search engine as a form of AI. A standard search engine combs the web and organizes the information into an index of links. The program does not generate text, images, code, or content.
}

There are a wide variety of tasks that fall in this domain. For today's lesson, we will focus on a single and commonplace example: spell checking. Copy editing a document without the help of a spell checker would be laborious and error-prone. We are so used to receiving spell checking help that sometimes we don't even notice or acknowledge the way in which it happens automatically.

When it comes to spell checking, how does the performance of a computer compare to that of a human? Do humans and computers use similar spell checking strategies?

@lesson-instruction{
- Complete @printable-exercise{human-spell-checking.adoc}.
- Be prepared to summarize the method that you used for spell checking:
** How do you locate misspelled words?
** How do you correct misspelled words?
}

You probably noticed that is was difficult to articulate how exactly you were able to locate and correct spelling mistakes. Why?

We are not computers! We rely on context clues and intuition. There were probably students in your class who said that the spelling mistakes jumped off the page. They couldn't *not* see the mistakes. Other students relied on context clues or prior knowledge to locate and fix errors. Of course, the process of spell-checking varies not just by person but by situation, too. If a different word had been misspelled, perhaps a multi-syllabic and complex technical word, you might have relied on a different spell checking strategy.

How can a computer possibly navigate such a nuanced and complex process? Stay tuned... you're about to find out!

=== Synthesize

@QandA{
@Q{What are some questions that you have about AI? What are you hoping to learn?}
@Q{What _confuses_ you about AI?}
}

@teacher{Consider writing down students' questions and possible misconceptions about AI. You can revisit these questions as  answers emerge in subsequent lessons.}



== The First Spell Checker @duration{25 minutes}

=== Overview

Students evaluate how spell checkers' programmed behaviors are both similar to and different from the behaviors of humans.

=== Launch

The very first spell checker was developed in 1961 at Stanford University's Artificial Intelligence Laboratory. Its creators provided the spell checker program with a 10,000-word dictionary and a precise algorithm to follow. Here is what the algorithm did:

[.indentedpara]
--
- *First*, it would develop alternative candidates for the misspelled word (input) by making one of the following adjustments: (1) replace a single letter with a different one, or (2) swap the positions of two adjacent letters.

- *Next*, it would search the provided dictionary to see which alternatives were valid options.

- *Finally*, it would produce a list of valid correctly spelled words for the user to choose from.
--

=== Investigate

Unsurprisingly, spell checkers have evolved a lot since 1961—but exploring this particular algorithm can offer us interesting insights about one of the earliest forms of AI.

@lesson-instruction{
- In Part 1 of @printable-exercise{first-spell-checker.adoc}, __you__ will be the computer, following the spell checking algorithm developed at Stanford University's Artificial Intelligence Laboratory in 1961.
- Once you've completed Part 1, move on to Part 2, where you will reflect on the activity.
}

@teacher{
After students have completed the activity, invite them to share their responses to the four reflection questions (below) in small groups.
}

@QandA{
@Q{What do you think are some limitations of the first spell checker's algorithm?}
@Q{How is the first spell checker's algorithm similar to whatever strategy *you* use when spell checking your writing?}
@Q{How is the first spell checker's algorithm different from whatever strategy *you* use when spell checking your writing?}
}


=== Synthesize

@QandA{
@Q{In what ways do spell checkers succeed at mimicking humans?}
@A{Based on the above, they do not at all!}
}

As you discovered during @printable-exercise{human-spell-checking.adoc}, when *you* spell check, you rely on many things, including intuition and context. The program we just discussed relies on computational brute force: even the most primitive spell checking program will repeatedly edit / transform a misspelled word, generating dozens of different strings to verify in the dictionary. Were a human to undergo this process, it would be time-consuming, laborious, and totally irrational... therefore highly error prone.



== Spell Checking in Pyret @duration{25 minutes}

=== Overview

Students explore both the algorithm and the datasets that power a Pyret-based spell checker, discovering that data-driven algorithms are at the heart of AI.

=== Launch

By now, we have a decent sense of the extensive work that is happening behind the scenes when we spell check our writing. We have *not*, however, discussed an essential truth about spell checkers and in fact *all modern Artificial Intelligence*: it is "data driven".

@QandA{
@Q{Where have you encountered the term "data driven" before, if at all?}
@Q{Have you ever met anyone who is "data driven"? (Teachers? Coaches? Parents?)}
@Q{What do you think it means to be "data driven"?}
}

=== Investigate

@lesson-instruction{
- Complete the first section of @printable-exercise{pyret-spell-checker.adoc} using the @starter-file{spell-checker}.
}

As you were interacting with the @starter-file{spell-checker}, you observed that it only proposed five-letter words. This is because the dictionary it draws from is actually a Wordle dictionary!

@teacher{Are you familiar with Wordle? If not, you can quickly learn the rules and play it @link{https://www.nytimes.com/games/wordle/index.html, "here"}. Before moving on with the lesson, be sure to check for students' familiarity with the game via a show of hands. If your students have _not_ played Wordle before, play one round as a class before proceeding.}

@left{@image{images/wordle.png, 175}}


Let's consider a partially-played Wordle game (left).


The player has attempted three words so far: "WORTH", "MEDIA", and "GAMES". With each turn, we have learned something new. At this point, we know that _a_, _m_, and _e_ belong in the 2nd, 3rd, and 4th tiles, respectively. We know that the 1st and 5th tiles are _not_ occupied by _w_, _o_, _r_, _t_, _h_, _d_, _i_, _g_, or _s_.

The player has just three turns left!

@QandA{
@Q{What word would _you_ try next?}
@A{Responses will vary; keep a list of student proposals.}

@Q{Each of the words you proposed was probably 2 edits away from "GAMES", the user's third guess. Why?}
@A{Three of the letters are correct; we just need to substitute in different letters for _g_ and _s_.}
}

@lesson-instruction{
- Complete @printable-exercise{pyret-spell-checker2.adoc} using the @starter-file{spell-checker}.
- If you finish early, try the two challenges at the bottom of the page.
}

When we offered _more data_ to our rudimentary Pyret spell checker, we got better results _without changing the code_.

Data is at the heart of data science, and @vocab{data-driven algorithms} are at the heart of AI. This statement is true not just of spell checkers, but of all artificial intelligence.

The type of data that we use to train artificial intelligence varies by situation, of course.

@lesson-instruction{
- Consider a different scenario, @printable-exercise{case-study-michelle.adoc}.
- Read the brief story and respond to the question, providing as much detail as you can.
}

@teacher{Invite students to share their responses, emphasizing that data-driven algorithms produce a higher quality output when we provide more data. Changing the code is not needed. When change to the code _does_ happen, it is done by humans.}

=== Synthesize






