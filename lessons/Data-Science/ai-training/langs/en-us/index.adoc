= Training Artificial Intelligence

@description{Students }

@ifproglang{pyret}{
@lesson-prereqs{ds-intro}
}

@ifproglang{codap}{
@lesson-prereqs{ds-intro}
}

@keywords{}

[@lesson-intro-table]
|===
| Lesson Goals
| Students will be able to...


| Student-facing Lesson Goals
|


| Materials
|[.materials-links]
@material-links

|===

== Plagiarism Detection

=== Overview

=== Launch

As a student, you probably know what it feels like to be under surveillance.

- When you enter your school, adults are stationed around the building and in the hallways. You might even go to a school that uses cameras to check that students are dressed and behaving a certain way.
- When you use the internet at your school or on a school-issued computer, software monitors your web use and blocks you from visiting a multitude of sites.
- When you take a test, your teacher likely paces around the classroom, ensuring that your eyes are on your paper.
- When you submit an essay to your English teacher, you can expect that they will check for plagiarism - perhaps by running it through a plagiarism detector to be certain that all words and thoughts are your own.

Sure, these surveillance tactics have their purposes... but being constantly watched is exhausting! Let's turn the tables and take a closer look at one method of surveillance: the plagiarism detector.

To ground our conversation, let's think about a very important question: Is it possible to _fool_ a plagiarism detector?

@QandA{
- Your teacher announces that they will be running all student writing through a plagiarism detector.
- You are a student who wants to plagiarize.
- Exercise some creativity: What are your strategies for evading detection?
}

@teacher{Go easy on your students! As students share their plagiarism strategies, you may feel judgmental. We urge you to keep those feelings at bay. _Adversarial Thinking_ - put simply, thinking like a hacker - is a strategy taught in cybersecurity courses at the university level. Data protection requires adversarial thinking. Instead of concluding that students who excel at thinking in this way are ethically compromised, consider commending their creativity and reasoning. After all, plagiarism is common. There is a strong likelihood that many of the students in your class have plagiarized in some way in the past, whether intentionally or not.
}

To understand the workings of plagiarism detection, we'll start by looking at a simple detector that _does not work very well_. First, it consumes documents from the internet. Next, we feed it a student student-submitted document. It compares the student document against the others to determine if there is a match.

@lesson-instruction{
- Open the Primitive Plagiarism Detector starter file.
- With a partner, complete @printable-exercise{primitive-plagiarism-detector.adoc}.
}

If the detector finds a match, we can be certain that an identical document exists. If the detector does not find a match, we know that there are no identical documents.

Either way, we can't draw any conclusions about whether plagiarism happened! As we discussed, plagiarizers usually alter at least a few words of the original document. Sometimes they change the ordering of the text, and sometimes they delete a sentence or word here and there. *We need a plagiarism detector with more sophistication!*

=== Investigate

Detecting identicality is not good enough. We need a different approach. We need to determine the _closeness_ of two documents. To do that, we need a way to summarize each document, and then assess closeness.

One standard way to summarize a document is by creating a "bag of words" model. Let's look at two documents (below). Each is an example of jazz "scatting", when a vocalist improvises with nonsense syllables. Consider these two strings:

- Document a: "doo be doo be doo"
- Document b: "doo doo be doo be"

The bag-of-words summary for Document A looks like this:

@math{"doo": 3, "be": 2}

As you can see, we've taken the original sentence and disregarded word order, creating an unordered collection that focuses solely on *word frequency*.

@lesson-point{
A bag-of-words model represents text as an unordered collection ("bag") of words.
}

With our bag of words, we have actually created a vector where each word represents one axis of the vector. Using vector notation, we can represent document A like this:

*NEED vector notation in mathjax?*

If we were to plot a point for the vector on the coordinate plane, it would produce this:

@center{@image{images/3-2.png, 200}}

@QandA{
@Q{What is the bag-of-words summary for Document b?}
@A{Because order does not matter, it is the same!}
@Q{How would you represent the vector for Document b on the coordinate plane?}
@A{It would be a point in the exact same position as the point for Document A.}
}

The bag-of-words summary for both documents is exactly the same! When the program takes stock of word frequency and ignores literally everything else, the two documents are a perfect match - each one resulting in a point on the coordinate plane at @math{(3,2)}.

Let's look at two slightly more complicated documents:

- Document c: "doo be doo be doo bop bop"
- Document d: "doo bop bop bop doo be doo be bop"

bag of words -
vector notation -
3d plotting -

If we imagine plotting a dot in a three-dimensional space, the point representing Document c will have the same position as the point representing Document d.

@strategy{A Five-Dimensional Space!?}{

@right{@image{images/5-cube.png, 150}}

Imagining higher dimensions is not easy! If you or your students are not able, that is okay. (After all, we are stuck in a three-dimensional world.) For AI, five dimensions - or even a thousand! - is no big deal. What's important for students to grasp is that a sequence of @math{N} numbers represents a location in an @math{N}-dimensional space.

The image to the right is a 2D representation of a 5-cube, which has 32 vertices, 80 edges, and 80 square faces.

}

@lesson-instruction{
- Open the Bag of Words Plagiarism Detector starter file.++
- With a partner, complete the first section of @printable-exercise{sophisticated-plagiarism-detector.adoc}.
}

When we use the bag-of-words model, the _new_ representation of the data is considerably smaller than the actual corpus.

@lesson-point{
Loss of data is a common and often necessary effect of training AI!
}

In this case, we have compressed the data by isolating the single feature that we care about: word frequency.

The computer's work is not yet complete. Normalizing the the data - organizing it so that each vector has the same number of axes - is essential. Data normalization enables us to consider the closeness of each of the documents.

@lesson-instruction{
Complete the second section of  @printable-exercise{sophisticated-plagiarism-detector.adoc}.
}

Our training phase is now complete. What does that mean?

Imagine a corpus of 60 documents. All together, these documents include 1000 unique words. In this scenario, the output of the training is a thousand-dimensional space with a collection of 60 unique points. Each axis represents one unique word, and each point represents a single document.

When we execute the program, the plagiarism detector computes the student's vector (the input!) and compares it against the other vectors.

We are about to play with a Bag of Words Plagiarism Detector. The program, built in Pyret, trains on just one text. It plots a point for that text and for one other text that the user provides.


@QandA{
@Q{If two points are plotted in exactly the same position, what is their distance from one another?}
@Q{What does it _mean_ when two points are plotted in the same position? Did plagiarism occur}
}

When two texts are exactly the same, the plagiarism detector produces an output of 1 - indicating that the vectors are 100% identical. If the vectors are entirely different, the plagiarism detector will produce an output of zero.


@strategy{How long does it take to train AI?}{
The plagiarism detector we will use, built in Pyret, trains on just a single text. Consequently, the training happens almost instantaneously.

Plagiarism detectors with bells and whistles, however, train on hundreds of thousands of texts collected from the internet. Like the training of ChatGPT (which took months!), this is a much more costly and time-intensive process.

AI really took off around 2010 because, at this time, more resources became available to train AI. Some, but not all, of these resources included: the increase of available data on the internet and the increased availability of graphics processing units (GPUs) to enable more efficient training.
}



@lesson-instruction{
- Open the Bag of Words Plagiarism Detector starter file.
- Complete the final section of @printable-exercise{sophisticated-plagiarism-detector.adoc}.
}


=== Synthesize


