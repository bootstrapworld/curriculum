@ifproglang{pyret}{
= Method Chaining

*Method chaining* allows us to apply multiple methods with less code.

@vspace{1ex}

For example, instead of using multiple definitions, like this:

  with-labels = animals-table.build-column("labels", nametag)
  cats = with-labels.filter(is-cat)
  cats.order-by("age", true)

We can use method-chaining to write it all on one line, like this:

  animals-table.build-column("labels", nametag).filter(is-cat).order-by("age", true)

*Order Matters!* The methods are applied in the order they appear. For example,
trying to order a table by a column that hasn’t been built will result in an error.
}

@ifproglang{codap}{
= Transformer Chaining

*Transformer chaining* allows us to apply multiple Transformers with fewer clicks.

@vspace{0.5ex}

Let's say we create the following Transformers:

- `build-in-kgs` - builds a new column with pounds converted to kilograms
- `filter-is-lightweight` - keeps all rows where weight is no more than 9 kilograms
- `sort-ascending` - sorts the dataset from lightest to heaviest weight

When we _save_ Transformers, we can apply them to new datasets - preventing lots of duplicate work. Additionally, when we have a chain of transformed datasets and change the original dataset, the updates will flow through the chain.

@vspace{0.5ex}

*Order Matters!* Transformers must be applied in the appropriate order given the dataset. For example, trying to order a table by a column that hasn’t been built will result in an error.
}
