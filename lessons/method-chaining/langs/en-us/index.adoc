= Method Chaining

@ifproglang{pyret}{
@description{Students learn how to chain Methods together, and define more sophisticated subsets.}
}

@ifproglang{codap}{
@description{Students learn how to chain Transformers together, and define more sophisticated subsets.}
}

@ifproglang{pyret}{
@lesson-prereqs{functions-dr, table-methods}
}

@ifproglang{codap}{
@lesson-prereqs{codap-transformers-2}
}

@keywords{}

[@lesson-intro-table]
|===
| Lesson Goals
| Students will be able to...

* Use chaining to write more sophisticated analyses using @ifproglang{pyret}{less code} @ifproglang{codap}{fewer clicks}

* Identify bugs introduced by chaining @ifproglang{pyret}{methods} @ifproglang{codap}{Transformers} in the wrong order

| Student-facing Lesson Goals
|

@ifproglang{pyret}{
* Let's practice writing functions and combining methods.
}
@ifproglang{codap}{
* Let's practice combining Transformers together.
}

| Materials
|[.materials-links]

@material-links

| Preparation
|
* All students should log into @starter-file{program-list} and open their saved "Animals Starter File". If they don't have the file, they can open a new one from @starter-file{animals}.
|===

== Design Recipe Practice @duration{25 minutes}

=== Overview
@ifproglang{pyret}{
Students practice more of what they learned in the previous lesson, applying the Design Recipe to make table functions that operate on rows of the Animals Dataset. These become the basis of the chaining activity that follows.}

@ifproglang{codap}{
In this lesson students build on what they have already learned to formalize their understanding of the Design Recipe, and then gain fluency with using the Design Recipe.}

=== Launch
@ifproglang{pyret}{The Design Recipe is a powerful tool for solving problems by writing functions.} @ifproglang{codap}{The Design Recipe is a sequence of steps that helps us document, test out, and write the expressions that our Transformers need to work properly - enabling us to thoughtfully analyze data!} It's important for this to be like second nature, so let's get some practice using it.

@ifproglang{codap}{
[.lesson-instruction]
- Let's look at this @printable-exercise{pages/design-recipe-1.adoc} worksheet together.

First, we need to decide which Transformer to use: Filter, Transform, or Build. Based on the Transformer's already-provided name, students should deduce that they will use Filter. They can then record the Transformer's name on the line.

@image{images/transformer-name.png, "top section of a Design Recipe", 800}

Next, we provide *example tables*. In this case, we want to know the animals' names and their species, so we write down those column names. We want to list a few different animals - at least one that is a dog, and at least one that is not - to represent the variety of animals on the table. Then we think about what our transformed table will look like:

- Will Sasha be on the new table? _No, Sasha is a cat. We only want dogs!_

- Will Fritz be on the new table? _Yes, Fritz is a dog._

- Will Toggle be on the new table? _Yes, Toggle is a dog._

@image{images/example-tables.png, "filled in example tables from Design Recipe worksheet", 800}

Now, we are ready to drill down on the contents of our Transformer.

- First - the *contract*, which requires a domain (what type of data will we provide) and a range (what type of data will be produced). Whenever we are filtering, we can expect the contract to be the same: Row -> Boolean.

- Next, we need a clear *purpose statement* which describes what the expression does to each row. In this case, the expression will consume an animal and compute whether the species is "dog" - as our example tables (above) demonstrate!

- And finally, we enter our *expression*, in this case: `species = "dog"`.

@image{images/contents.png, "contract, purpose statement, expression", 800}

Each time students encounter a new word problem, we encourage working through it with paper and pencil, as above; the Design Recipe slows down students' thinking and encourages them to reason through each scenario fully rather than guessing haphazardly.
}

=== Investigate
[.lesson-instruction]
- Open your saved @starter-file{animals}.
- Define the @ifproglang{pyret}{functions} @ifproglang{codap}{Transformers and  expressions} on @ifproglang{pyret}{@printable-exercise{pages/design-recipe-1.adoc} and} @printable-exercise{pages/design-recipe-2.adoc}.


[.strategy-box, cols="1", grid="none", stripes="none"]
|===
|
@span{.title}{Optional: Combining Booleans}

Suppose we want to build a table of Animals that are fixed _and_ old, or a table of animals that are cats _or_ dogs?

By using the `and` and `or` operators, we can _combine_ Boolean tests @ifproglang{codap}{on a single Transformer, like `Filter`.} @ifproglang{pyret}{, as in: `(1 > 2) and ("a" == "b")`} @ifproglang{codap}{Once we've opened the `Filter` Transformer, we would tell CODAP to keep all rows that satisfy `Species = "cat" and Species = "dog"`}. This is handy for more complex programs! For example, we might want to ask if a character in a video game has run out of health points _and_ if they have any more lives. We might want to know if someone’s ZIP Code puts them in Texas or New Mexico. When you go out to eat at a restaurant, you might ask what items on the menu have meat and cheese.

@ifproglang{pyret}{For many of the situations where you might use `and`, there's actually a much more powerful mechanism you can use, called "Method Chaining"!} @ifproglang{codap}{When we want to chain together _different_ Transformers, however, this strategy will not work. We'll need to find another way!}
|===

=== Synthesize
- Did you find yourselves getting faster at using the Design Recipe?
- What patterns or shortcuts are you noticing, when you use the Design Recipe?

== Chaining @duration{25 minutes}

=== Overview
Students learn how to compose multiple table operations (sorting, filtering, building) on the same table - a technique called "chaining".

=== Launch

//////////////////////////
Pyret-specific content
//////////////////////////
@ifproglang{pyret}{
Suppose we start with the number 1, and want to add 2, 6 and 3 to it. The code below will get the job done:
```
x = 1 + 2
y = x + 6
result = z + 3
```

[.lesson-instruction]
Why is this code ugly, or hard to read?

This code breaks up each step of the computation in steps, and creates names for each step. But we don't really care about `x` or `y` -- we just want the final answer `result`!

We can easily _chain these operators together_, to do all the calculation in one line of code:
```
result = 1 + 2 + 6
```

[.lesson-instruction]
- Open your saved Table Methods Starter File (or @starter-file{table-methods, open a new one}), and click "Run".
- Can you make a table with a new column called "nametag" that is populated using the `label` function?
- Can you take _that_ table, and filter it so it only shows the fixed animals?
- Can you sort _that_ table by species?

Here's some code that will solve the challenges above:
```
x = animals-table.build-column("labels", nametag)
y = with-labels.filter(is-fixed)
result = fixed-with-labels.order-by("species", true)
```

[.lesson-instruction]
Why is this code ugly, or hard to read?

This code breaks up each step of the computation in steps, and creates names for each step. But we don't really care about `x` or `y` -- we just want the final answer `result`!

Pyret allows table methods to be _chained together_, so that we can build, filter _and_ order a Table in one shot. For example:

```
result = animals-table.build-column("labels", nametag).filter(is-fixed).order-by("species", true)
```

Let's walk through this line of code one step at a time:

- We take the `animals-table`, and produce a new table with an extra column called `label`.
- Then call _that_ Table's `.filter` method, producing a new table with a `label` column and only rows for fixed animals.
- Then we call _that_ Table’s `order-by` method, producing a new, sorted table of fixed animals with a `label` column.

[.strategy-box, cols="1", grid="none", stripes="none"]
|===
|
@span{.title}{Teaching Tip}

Use different color markers to draw _nested boxes_ around each part of the expression, showing each of the three steps described above.
|===

It can be difficult to read code that has lots of method calls chained together, so we can add a line-break before each `.` to make it more readable. Here’s the exact same code, written with each method on its own line:

```
# get a table with the nametags of all
# the fixed animals, order by species
animals-table
  .build-column("label", nametag)
  .filter(is-fixed)
  .order-by("species", true)
```
}

//////////////////////////
CODAP-specific content
//////////////////////////
@ifproglang{codap}{
Now that we are doing more sophisticated analyses, we might find ourselves in a situation where we want to use a series of Transformers!

Suppose a journalist comes to the shelter who wants to write a story about a successful pet adoption -- but she has a very specific set of criteria. The reporter wants to report on the adoption of an animal that weighs no more than 9 kilograms. She also wants to review an updated copy of the dataset each week (reflecting changes to the shelter's population) before making a decision about which animal to showcase.

In CODAP, we can use the result of one Transformer as the dataset for another Transformer! To help the journalist, you decide that you want to use *two* Transformers: _Build Attribute_ and _Filter_. But in which order?

[.lesson-instruction]
- The _Build Attribute_ Transformer we must define uses this formula: `pounds/2.205`. It also requires that we provide a name for our new attribute, such as `kilograms`.
- The _Filter_ Transformer that we must define uses this formula: `kilograms<9`.
- Which of the two above Transformers should we apply _first_, `weight-in-kg` or `filter-if-light`?
- What do you predict will happen if we apply them in the wrong order? Why?

A perk of applying Transformers, rather than manipulating the dataset, is that any updates made to the original dataset will flow through the chain. As you chain together Transformers, it is important to remember the following:
}
[.lesson-point]
Order matters: Build / Transform, Filter, Sort.

Suppose we want to build a column and then use it to filter our table. If we use the @ifproglang{pyret}{methods} @ifproglang{codap}{Transformers} in the wrong order (trying to filter by a column that doesn’t exist yet), we might wind up crashing the program. Even worse, the program might work, but produce results that are incorrect!

@ifproglang{codap}{

[.strategy-box, cols="1", grid="none", stripes="none"]
|===
|
@span{.title}{Tip: Saving Transformers and Renaming Tables}

Saving a particular configuration of a Transformer is useful so that the Transformer can be easily accessed in the future. When we save a Transformer, we want to give it a useful name and purpose statement for ease of use later.

We also encourage students to rename tables descriptively. By the end of this exercise, the table students create will have quite a lengthy name: `(weight-in-kg(filter-if-light(Animals-Dataset)))`. That's a lot of parentheses! As an alternative, students might consider using renaming the table. For instance, `light-animals-in-kg` might be a more useful table name, here.
|===

}
=== Investigate
[.lesson-point]
When chaining @ifproglang{pyret}{methods} @ifproglang{codap}{Transformers}, it’s important to build @ifproglang{codap}{and transform} first, then filter, and then order.

How well do you know your @ifproglang{pyret}{table methods} @ifproglang{codap}{Transformers}? Complete @printable-exercise{pages/chaining-methods.adoc} and @printable-exercise{pages/chaining-methods-order-matters.adoc} in to find out.


=== Synthesize
Ask students about their answers to @printable-exercise{pages/chaining-methods-order-matters.adoc}.

- Which ones produced an error?
- Why will they produce an error?
- How could they be fixed?

Can students trigger a similar error in their Table Methods starter file?

As our analysis gets more complex, chaining is a great way to re-use code we've already written. And less code means a smaller chance of bugs.

@ifproglang{codap}{

== Additional Exercises
- @opt-printable-exercise{pages/chaining-methods-table-transformations.adoc}

}
