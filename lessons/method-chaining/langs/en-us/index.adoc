= Method Chaining

@lesson-description{Students learn how to chain Methods together, and define more sophisticated subsets. }

[@lesson-intro-table]
|===
@prereqs-stds{defining-table-functions}
| Lesson Goals
| Students will be able to...

* Use method chaining to write more sophisticated analyses using less code
* Identify bugs introduced by chaining methods in the wrong order

| Student-facing Lesson Goals
|

* Let's practice writing functions and combining methods together.

| Materials
|[.materials-links]
* @link{https://docs.google.com/presentation/d/1jBoQJfEf8-SuAEEu3Y-u_aYdEEjAQEjOM4G-kv6I9y4/, Lesson Slides}
* @link{https://code.pyret.org/editor#share=1ZupMVPWvVUOM0HCWyA7cRBghSLKxPWv1, Animals Starter File}

@material-links

| Preparation
|
* Make sure all materials have been gathered
* Decide how students will be grouped in pairs
* Computer for each student (or pair), with access to the internet* All students should log into @link{https://code.pyret.org, CPO} and open the "Animals Starter File" they saved from the prior lesson. If they don't have the file, they can @link{https://code.pyret.org/editor#share=1ZupMVPWvVUOM0HCWyA7cRBghSLKxPWv1, open a new one}
* link:{pathwayrootdir}/workbook/workbook.pdf[Student workbook], and something to write with

| Supplemental Resources
|

@lang-prereq
|===

== Design Recipe Practice @duration{25 minutes}

=== Overview

Students practice more of what they learned in the previous lesson, applying the Design Recipe to make @ifproglang{codap}{Transformers} @ifproglang{pyret}{table functions} that operate on rows of the Animals Dataset. These become the basis of the chaining activity that follows.

=== Launch
The Design Recipe is a powerful tool for solving problems by writing functions. It's important for this to be like second nature, so let's get some more practice using it!

=== Investigate
[.lesson-instruction]
Define the Compute functions on @printable-exercise{pages/design-recipe-1.adoc} and @printable-exercise{pages/design-recipe-2.adoc}.

[.strategy-box, cols="1", grid="none", stripes="none"]
|===
|
@span{.title}{Optional: Combining Booleans}

Suppose we want to build a table of Animals that are fixed _and_ old, or a table of animals that are cats _or_ dogs?

By using the `and` and `or` operators, we can _combine_ boolean tests @ifproglang{codap}{on a single function, like `Filter`}, as in: @ifproglang{pyret}{`(1 > 2) and ("a" == "b")`} @ifproglang{codap}{`Species = "cat" and Species = "dog"`}. This is handy for more complex programs! For example, we might want to ask if a character in a video game has run out of health points _and_ if they have any more lives. We might want to know if someone’s ZIP Code puts them in Texas or New Mexico. When you go out to eat at a restaurant, you might ask what items on the menu have meat and cheese.

@ifproglang{pyret}{For many of the situations where you might use `and`, there's actually a much more powerful mechanism you can use, called "Method Chaining"!} @ifproglang{codap}{When we want to chain together _different_ Transformers, however, this strategy will not work. We'll need to find another way!}
|===



=== Synthesize
Did students find themselves getting faster at using the Design Recipe? Can students share any patterns they noticed, or shortcuts they used?

== Chaining @duration{25 minutes}

=== Overview
Students learn how to compose multiple table operations (sorting, filtering, building) on the same table - a technique called "chaining".


=== Launch
@ifproglang{pyret}{
Now that we are doing more sophisticated analyses, we might find ourselves writing the following code:
----
# get a table with the nametags of all the fixed animals, ordered by species
with-labels = animals-table.build-column("labels", nametag)
fixed-with-labels = with-nametags.filter(is-fixed)
result = fixed-with-labels.order-by("species", true)
----

That's a lot of code, and it also requires us to come up with names for each intermediate step! Pyret allows table methods to be _chained together_, so that we can build, filter _and_ order a Table in one shot. For example:

----
# get a table with the nametags of all the fixed animals, ordered by species
result = animals-table.build-column("labels", nametag).filter(is-fixed).order-by("species", true)
----

This code takes the `animals-table`, and builds a new column. According to our Contracts Page, `.build-column` produces a new Table, and that’s the Table whose `.filter` method we use. That method produces _yet another Table_, and we call that Table’s `order-by` method. The Table that comes back from that is our final result.


[.strategy-box, cols="1", grid="none", stripes="none"]
|===
|
@span{.title}{Teaching Tip}

Use different color markers to draw _nested boxes_ around each part of the expression, showing where each Table came from.
|===

It can be difficult to read code that has lots of method calls chained together, so we can add a line-break before each “`.`” to make it more readable. Here’s the exact same code, written with each method on its own line:

----
# get a table with the nametags of all the fixed animals, order by species
animals-table
  .build-column("label", nametag)
  .filter(is-fixed)
  .order-by("species", true)
----
}
@ifproglang{codap}{
Now that we are doing more sophisticated analyses, we might find ourselves in a situation where we want to use a series of transformers!

Let’s say that a journalist comes to the shelter. She wants to write a story about a successful pet adoption--but she has a very specific set of criteria. The reporter wants to report on the adoption of a fixed animal that weighs no more than 9 kilograms. She wants to consider all eligible animals in order from lightest to heaviest.

This reporter also informs you that it might take some time for her to find the perfect pet adoption scenario. Until she finds what she’s looking for, she wants a weekly updated list of the pets who meet her criteria.

Let's break down the reporter's specifications:
[.lesson-instruction]
- Give the weight in kilograms.
- Include only fixed animals.
- Include only animals that weigh less than 9 kilograms.
- Order weight in kilograms from lightest to heaviest.
- Update the table weekly to reflect the changing population of the shelter.

The journalist has a lot of needs!

Fortunately, in CODAP, we can use the result of one transformer as an input to another. In other words: transformers can be chained, resulting in a sequence of datasets, each a transformed version of the previous. Any updates made to an input dataset will flow through and affect its outputs. If you have a chain of transformed datasets and you change the original dataset, the updates will flow through the chain.

As you chain together transformers, it is important to remember the following:
}
[.lesson-point]
Order matters: Build, Filter, Order.

Suppose we want to build a column and then use it to filter our table. If we use the @ifproglang{pyret}{methods} @ifproglang{codap} in the wrong order (trying to filter by a column that doesn’t exist yet), we might wind up crashing the program. Even worse, the program might work, but produce results that are incorrect!

@ifproglang{codap}{
[.strategy-box, cols="1", grid="none", stripes="none"]
|===
|
@span{.title}{Tip: Saving Transformers}
Transformers can be saved! Saving a particular configuration of a transformer is useful so that the transformer can be easily accessed in the future. When we save a transformer, we’ll want to give it a useful name and purpose statement, just like we practiced earlier in this lesson.

Once a transformers is saved, students can abstract over a particular computation that they want to perform on the data (the way functions in Algebra are abstractions over computations in arithmetic).
|===
}
Let’s go through how we might meet the journalist’s needs.

[.lesson-instruction]
- Give the weight in kilograms.

For this step, we’ll use `Build Attribute`, which makes a new copy of the dataset, adding a `Weight (kgs)` column.

[.lesson-instruction]
- Include only fixed animals.

Here, we are going to apply the `Filter` transformer _not_ to our original Animals Dataset, but to the transformed copy of the original dataset. When we select `Dataset to Filter`, we must choose `BuildAttribute(Animals-Dataset)`. We will then specify that we want to keep all rows that satisfy `Fixed = “TRUE”`.

[.lesson-instruction]
- Include only animals that weigh less than 9 kilograms.

We are going to `Filter` again, but this time we apply the transformer to the dataset we created in the previous step. In the dropdown menu of datasets, our dataset is named `Filter{BuildAttribute(Animals-Dataset)`.

[.lesson-instruction]
- Order weight in kilograms from lightest to heaviest.

Remember - we want to be able to easily create a table that meets the journalist’s specifications, so we’ll want to use the `Sort` transformer here, rather than the `Sort` dropdown option that appears when we click `Weight`. Be sure to select the correct dataset to sort!

[.lesson-instruction]
- Update the table weekly to reflect the changing population of the shelter.

Because we’re using transformers, each time the Animals Table is updated, the journalist’s table will be updated, too! Try adding or removing a row from the original table and observe the ripple effect in your chained tables.}

=== Investigate
[.lesson-point]
When chaining @ifproglang{pyret}{methods} @ifproglang{codap}{transformers}, it’s important to build first, then filter, and then order.

How well do you know your table methods? Complete @printable-exercise{pages/chaining-methods.adoc} and @printable-exercise{pages/chaining-methods-order-matters.adoc} in your Student Workbook to find out.}


=== Synthesize
As our analysis gets more complex, chaining @ifproglang{pyret}{methods} @ifproglang{codap}{Transformers} is a great way to re-use work we've already done. And less duplicate work means a smaller chance of bugs. Composing operations is a powerful way to work, so it’s critical to think carefully when we use it!


== Additional Exercises
- @opt-printable-exercise{pages/chaining-methods-table-transformations.adoc}
